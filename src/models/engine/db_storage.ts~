import "reflect-metadata";
import { Connection, ConnectionManager, Repository, ObjectType } from 'typeorm';
import * as dotenv from 'dotenv';
import { BaseModel } from '../base_model';
import { UsersApp } from '../user';
import { UserTypeApp } from '../usertype';
import { MotorCycle } from '../moto';
/*
import { Capital } from '../capital';
import { Category } from '../category';
import { CreditDetail } from '../credit_detail';
import { CreditPayment } from '../creditpayment';
import { Credit } from '../credit';
import { DriverLicense } from '../driverlicense';
import { InversionDetail } from '../inversionDetail';
import { Inversion } from '../inversion';

import { Movement } from '../movement';
import { MovementType } from '../movementType';
import { Product } from '../product';
import { Withdrawal } from '../withdrawl';

import { Connection } from "typeorm";
import { createConnection } from 'net';
*/


export class DBStorage {

    private _engine: Connection = null;
    private _listObjects: { [key: string]: BaseModel } = {};
    private _classes = [
        { 'name': 'UsersApp', 'obj': UsersApp, 'db': 'users_app' },
        { 'name': 'UserTypeApp', 'obj': UserTypeApp, 'db': 'user_type_app' },
        { 'name': 'MotorCycle', 'obj': MotorCycle, 'db': 'motor_cycle' }
        /*{ 'name': 'Capital', 'obj': Capital },
        { 'name': 'Category', 'obj': Category },
        { 'name': 'CreditDetail', 'obj': CreditDetail },
        { 'name': 'CreditPayment', 'obj': CreditPayment },
        { 'name': 'Credit', 'obj': Credit },
        { 'name': 'DriverLicense', 'obj': DriverLicense },
        { 'name': 'InversionDetail', 'obj': InversionDetail },
        { 'name': 'Inversion', 'obj': Inversion },

        { 'name': 'Movement', 'obj': Movement },
        { 'name': 'MovementType', 'obj': MovementType },
        { 'name': 'Product', 'obj': Product },
        { 'name': 'Withdrawal', 'obj': Withdrawal }*/
    ];

    constructor() {
        dotenv.config({
            path: '/home/root/new_project_v2/MysqlProject/src/.env'
        });
        //console.log(process.env.HBNB_MYSQL_USER);

        const connectionManager = new ConnectionManager();
        this._engine = connectionManager.create({

            type: "mysql",
            host: process.env.HBNB_MYSQL_PORT,
            port: parseInt(process.env.HBNB_PORT),
            username: process.env.HBNB_MYSQL_USER,
            password: process.env.HBNB_MYSQL_PWD,
            database: process.env.HBNB_MYSQL_DB,
            entities: ["build/entity/**/*.js"],
            synchronize: true,
            logging: false
        });


    }

    public all(cls?: any): { [key: string]: any } {

        //console.log(`list odfdsdfsdfsdsbjs  ${Object.entries(this._listObjects).length}`);
        if (cls) {
            let objCopy: { [key: string]: any } = {};
            //console.log(`cls ${cls}  is ${cls.constructor.name}`);

            for (let key in this._listObjects) {
                let k = key.split('.');
                //console.log(`k : ${k[0]}    cls ${cls}`);
                if (k[0] === cls) {
                    objCopy[key] = this._listObjects[key];
                    //console.log(`list odfdsdfsdfsdsbjs  ${this._listObjects[key]}`);
                    //console.log('all uno');
                }
            }
            return (objCopy);
        }
        //console.log(`list objs all method  ${Object.entries(this._listObjects)}`);
        //console.log(`list objs all method  ${Object.entries(this._listObjects).length}`);
        return (this._listObjects);
    }

    public async new(baseModel: any): Promise<void> {

        try {
            let index = this._classes.findIndex((item) => {
                return item.name === baseModel.constructor.name;
            });

            const repository: Repository<typeof baseModel> = this._engine.getRepository(this._classes[index].db);
            await repository.save(baseModel);

            let key = `${baseModel.constructor.name}.${baseModel.id}`;
            this._listObjects[key] = baseModel;
        } catch (e) {
            console.error(`\n\nError inserting db: \n\t${e} \n\t${e.message} `);
        }
    }

    public async save(baseModel?: BaseModel): Promise<void> {

        //console.log(`baseModel  ${baseModel}`);

        //if (baseModel) {
        //let objClass = stringJson[k]['__class__'];
        try {

            //console.log(`base: ${baseModel}`);

            let index = this._classes.findIndex((item) => {
                return item.name === baseModel.constructor.name;
            });

            const repository: Repository<typeof baseModel> = this._engine.getRepository(this._classes[index].db);
            //const objreceived = await repository.findOne(baseModel.id);
            //let obj = new this._classes[index].obj(objreceived);
            //Object.assign(obj, baseModel);

            await repository.save(baseModel);

            let key = `${baseModel.constructor.name}.${baseModel.id}`;
            this._listObjects[key] = baseModel;
        } catch (e) {
            console.error(`\n\nError deleting db: \n\t${e} \n\t${e.message} `);
        }

    }

    public async delete(baseModel: any): Promise<void> {

        try {
            let index = this._classes.findIndex((item) => {
                return item.name === baseModel.constructor.name;
            });
            const repository: Repository<typeof baseModel> = this._engine.getRepository(this._classes[index].db);
            await repository.delete(baseModel.id);

            let key = `${baseModel.constructor.name}.${baseModel.id}`;
            if (key in this._listObjects) {
                delete this._listObjects[key];
            }
        } catch (e) {
            console.error(`\n\nError deleting db: \n\t${e} \n\t${e.message} `);
        }

    }

    public async reload(): Promise<void> {

        try {
            await this._engine.connect();
            console.log(`\nstatus connection db: ${this._engine.isConnected} `);
        } catch (e) {
            console.error(`\n\nError connection db: \n\t${e} \n\t${e.message} `);
        }
        for (let i in this._classes) {

            let obj = new this._classes[i].obj;
            const repository: Repository<typeof obj> = this._engine.getRepository(this._classes[i].db);
            let instance = await repository.find();

            //console.log(` instance: ${instance} type: ${instance.constructor.name}
            //instance0: ${ instance[0] } type: ${ instance[0].constructor.name } `);

            for (let j in instance) {
                //console.log(`-- > ss   ${instance[j].id} `);
                let key = `${instance[j].constructor.name}.${instance[j].id}`;
                //console.log(` key: ${key} value: ${instance[j]} type: ${instance[j].constructor.name} `);
                //console.log(`${instance[j].firstName}`);
                this._listObjects[key] = new this._classes[i].obj(instance[j]);
                //console.log(`list objs  ${this._listObjects[key]}`);
            }

        }
        //console.log(`-- > dfdfdf ${this._listObjects} count ${Object.entries(this._listObjects).length} `);

    }

    public async closeSession(): Promise<void> {
        try {
            await this._engine.close();
            console.log(`\nclose session db: ${this._engine.isConnected} `);
        } catch (e) {
            console.error(`\n\nError connection db: \n\t${e} \n\t${e.message} `);
        }
    }

    /**
     * retrieves one object based on class name and id
     */
    public getObj(cls?: string, id?: string): any {
        if (cls && id) {
            let fetch_obj = `${cls}.${id}`;
            let allObj = this.all(cls);
            if (fetch_obj in allObj) {
                return (allObj[fetch_obj])
            }
        }
        return null;
    }

    /**
     * count of all objects in storage
     */
    public count(cls?: string): number {
        return (Object.entries(this.all(cls)).length);

    }

}
